Terminals:
( ) none , and or not true false + - * / % = < > ! is in " ' [ ] { } for : # if elif else while break
Variables:
SS NL ALPHABET DIGIT OTHER SYNTAX BODY SERU HASHTAG PERSEN NBO NBC MUL PLUS MIN COMA POW DIVIDE DIV COLON SEMICOLON LESS EQUAL GREAT SBO SBC UNDERSCORE CBO CBC PETIK1 PETIK2 ALPHANUM STRING_QORD VAR_FIRST VAR LET VALUE NUMBER VV BOOLEAN OP EXPRESSION RELATION STRING ARRAY RANGE DICT_CONTENT DICT COMMENT IF_HEADER ELIF_HEADER ELIF ELSE WHILE WHILE_HEADER FOR_HEADER FOR FOR_VAR ITERABLE ITERATE CONTINUE BREAK PASS DEF_HEADER DEF_S DEF RETURN FUNC_BODY IF_FUNC ELIF_FUNC ELSE_FUNC WHILE_FUNC FOR_FUNC WITH_FUNC ITERATE_FUNC BREAK_FUNC CONTINUE_FUNC CLASS CLASS_HEADER CLASS_S IMP_S IMPORT WITH WITH_HEADER FUNCTION NONES ANDS ORS ISS INS TRUES FALSES NOTS FORS IFS ELIFS ELSES WHILES BREAKS CONTINUES DEFS RETURNS RANGES CLASSS FROMS IMPORTS ASS WITHS CASE CASE_HEADER CASE_EX CASES SWITCH SWITCH_CONTENT SWITCH_HEADER SWITCHS DEFAULT DEFAULT_HEADER DEFAULTS DELETE FINALLY NULL THROW TRY
Production:

SS -> SS SEMICOLON NL SS SEMICOLON NL | NL SS SEMICOLON NL | SS SEMICOLON NL | IF | WHILE | SWITCH | FOR | CLASS | DEF | IMPORT | COMMENT | BREAK | FUNCTION | CONTINUE | WITH | PASS | VAR EQUAL VV | VAR OP EQUAL VV | NONES | VV;
ALPHABET -> a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z;
DIGIT -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
OTHER -> $ | & | . | ? | @ | \ | ^ | ` | ~ | SERU | HASHTAG | PERSEN | NBO | NBC | MUL | PLUS | MIN | COMMA | DIVIDE | COLON | SEMICOLON | LESS | EQUAL | GREAT | SBO | SBC | UNDERSCORE | CBO | CBC | |;
SYNTAX -> NONES | ANDS | ORS | ISS | INS | TRUES | FALSES | NOTS | FORS | IFS | ELIFS | ELSES | WHILES | BREAKS | CONTINUES | DEFS | RETURNS | RANGES | CLASSS | FROMS | IMPORTS | ASS | WITHS;
NL -> NL NL | newline;

VAR_FIRST -> ALPHABET | UNDERSCORE;
ALPHANUM -> ALPHANUM ALPHANUM | DIGIT | VAR_FIRST;
VAR_VARIABLE -> VAR_FIRST ALPHANUM | VAR_FIRST;
VARS -> VAR VAR_VARIABLE EQUAL VALUE NL | VAR VAR_VARIABLE EQUAL VALUE SEMICOLON | VAR VAR_VARIABLE EQUAL VALUE SEMICOLON NL;
LETS -> LET VAR_VARIABLE EQUAL VALUE NL | LET VAR_VARIABLE EQUAL VALUE SEMICOLON | LET VAR_VARIABLE EQUAL VALUE SEMICOLON NL;
  
NUMBER -> NUMBER NUMBER | DIGIT;
STRING_WORD -> STRING_WORD STRING_WORD | ALPHABET | DIGIT | OTHER | SYNTAX;
VALUE -> NUMBER | BOOLEAN | STRING | ARRAY | DICT | FUNCTION | VV OP VV | NBO VV NBC | NONES;
VV -> VV COMMA VV | VALUE | VAR | VV IFS EXPRESSION ELSES VV;
BOOLEAN -> BOOLEAN ANDS BOOLEAN | BOOLEAN ORS BOOLEAN | NOTS BOOLEAN | VV RELATION VV | TRUES | FALSES | NBO BOOLEAN NBC | VALUE | VAR;
OP -> PLUS | MIN | MUL | DIVIDE | DIV | POW | PERSEN;
EXPRESSION -> BOOLEAN | NBO BOOLEAN NBC;
RELATION -> GREAT EQUAL | LESS EQUAL | EQUAL EQUAL | SERU EQUAL | LESS | GREAT | ISS | ISS NOTS | INS | NOTS INS;
STRING -> STRING STRING | PETIK2 STRING_WORD PETIK2 | PETIK1 STRING_WORD PETIK1;
ARRAY -> SBO VV SBC | SBO SBC | SBO VV FORS VAR INS VV SBC | SBO VV FORS VAR INS RANGE SBC | VAR SBO VV SBC;
RANGE -> RANGES NBO VV NBC;
CASE -> CASE_HEADER SS;
CASE_HEADER -> CASES CASE_EX COLON;
CASE_EX -> STRING_WORD | BOOLEAN | VALUE | NBO STRING_WORD NBC | NBO BOOLEAN NBC | NBO VALUE NBC;
CASES -> case
DEFAULT -> DEFAULT | CASE NL DEFAULT | DEFAULT_HEADER SS;
DEFAULT_HEADER -> DEFAULTS COLON;
DEFAULTS -> default;
DELETE -> cobadulu
FINALLY -> cobadulu
NULL -> cobadulu
SWITCH -> SWITCH_HEADER CBC | SWITCH_HEADER DEFAULT CBC;
SWITCH_HEADER -> SWITCHS VALUE CBO | SWITCHS VALUE CBO NL;
SWITCHS -> switch
THROW -> cobadulu
TRY -> cobadulu
DICT -> CBO CBC | CBO DICT_CONTENT CBC | VAR SBO VV SBC;
DICT_CONTENT -> VV COLON VV | DICT_CONTENT , DICT_CONTENT;
BODY -> STRING_WORD | BODY NL BODY | NL BODY | BODY NL;
COMMENT -> DIVIDE STRING_WORD DIVIDE NL | DIVIDE MUL BODY MUL DIVIDE;
IF_HEADER -> IFS EXPRESSION CBO NL;
IF -> IF_HEADER SS CBC  | IF NL ELIF | IF NL ELSE | IF_HEADER BREAKS SEMICOLON NL SS CBC | IF_HEADER CONTINUES SEMICOLON NL SS CBC | IF_HEADER BREAKS SEMICOLON NL CBC | IF_HEADER CONTINUES SEMICOLON NL CBC;
ELIF_HEADER -> ELIFS EXPRESSION CBO NL;
ELIF -> ELIF_HEADER SS CBC | ELIF NL ELIF | ELIF NL ELSE | ELIF_HEADER BREAKS SEMICOLON NL SS CBC | ELIF_HEADER CONTINUES SEMICOLON NL SS CBC | ELIF_HEADER BREAKS SEMICOLON NL CBC | ELIF_HEADER CONTINUES SEMICOLON NL;
ELSE -> ELSES CBO NL SS CBC | ELSES CBO NL BREAKS SEMICOLON NL CBC | ELSES CBO NL CONTINUES SEMICOLON NL CBC | ELSES CBO NL BREAKS SEMICOLON NL SS CBC | ELSES CBO NL CONTINUES SEMICOLON NL SS;
WHILE_HEADER -> WHILES EXPRESSION CBO NL;
WHILE -> WHILE_HEADER SS CBC;


FOR_HEADER1 -> FORS NBO FOR_VAR NBC CBO NL | FORS NBO FOR_VAR INS FOR_VAR NBC CBO NL;
FOR_HEADER2 -> FR
FOR_VAR -> VAR_VARIABLE EQUAL VAR_VARIABLE SEMICOLON | FOR_VAR FOR_VAR;
ITERABLE -> RANGE | NBO DICT NBC | DICT | NBO ARRAY NBC | ARRAY | STRING | FUNCTION;
FOR -> FOR_HEADER SS CBC;
ITERATE -> FOR_HEADER | WHILE_HEADER | FOR | WHILE;
BREAK -> ITERATE BREAKS | ITERATE BREAKS NL SS;
CONTINUE -> ITERATE CONTINUES | ITERATE CONTINUES NL SS;
PASS -> pass;


FUNCTION -> VAR NBO VV NBC | VAR NBO NBC;
DEF_HEADER -> DEFS VAR NBO VV NBC COLON NL | DEFS VAR NBO NBC COLON NL;
DEF_S -> DEF_S NL DEF_S | DEF_S NL | FUNC_BODY;
FUNC_BODY -> FUNC_BODY NL FUNC_BODY | FUNC_BODY NL | IF_FUNC | FOR_FUNC | WHILE_FUNC | CONTINUE_FUNC | BREAK_FUNC | CLASS | DEF | VAR EQUAL VV | VAR OP EQUAL VV | IMPORT | FUNCTION | WITH_FUNC | PASS | RETURN | COMMENT | NONES;
DEF -> DEF_HEADER DEF_S | DEF_HEADER FUNC_BODY;
RETURN -> RETURNS BOOLEAN | RETURNS VV | RETURNS;
IF_FUNC -> IF_HEADER FUNC_BODY | IF_FUNC NL ELIF_FUNC | IF_FUNC NL ELSE_FUNC | IF_HEADER BREAKS NL FUNC_BODY | IF_HEADER CONTINUES NL FUNC_BODY | IF_HEADER BREAKS | IF_HEADER CONTINUES;
ELIF_FUNC -> ELIF_HEADER FUNC_BODY | ELIF_FUNC NL ELIF_FUNC | ELIF_FUNC NL ELSE_FUNC | ELIF_HEADER BREAKS NL FUNC_BODY | ELIF_HEADER CONTINUES NL FUNC_BODY | ELIF_HEADER BREAKS | ELIF_HEADER CONTINUES;
ELSE_FUNC -> ELSES COLON NL FUNC_BODY | ELSES COLON NL BREAKS | ELSES COLON NL CONTINUES | ELSES COLON NL BREAKS NL FUNC_BODY | ELSES COLON NL CONTINUES NL FUNC_BODY;
FOR_FUNC -> FOR_HEADER FUNC_BODY;
WHILE_FUNC -> WHILE_HEADER FUNC_BODY;
ITERATE_FUNC -> FOR_FUNC | WHILE_FUNC | WHILE_HEADER | FOR_HEADER;
CONTINUE_FUNC -> ITERATE_FUNC CONTINUES | ITERATE_FUNC CONTINUES NL FUNC_BODY;
BREAK_FUNC -> ITERATE_FUNC BREAKS | ITERATE_FUNC BREAKS NL FUNC_BODY;
CLASS_HEADER -> CLASSS VAR COLON NL | CLASSS VAR NBO VV NBC COLON NL | CLASSS VAR NBO NBC COLON NL;
CLASS_S -> CLASS_S NL CLASS_S | CLASS_S NL | IF | WHILE | FOR | CLASS | DEF | FUNCTION | VAR EQUAL VV | VAR OP EQUAL VV | BREAK | CONTINUE | PASS | COMMENT;
CLASS -> CLASS_HEADER CLASS_S;
IMPORT -> FROMS VAR IMPORTS IMP_S | IMPORTS VAR ASS VAR | IMPORTS VAR | IMPORT NL;
IMP_S -> MUL | VAR ASS VAR | VAR | IMP_S NL;
SERU -> !;
HASHTAG -> #;
PERSEN -> %;
NBO -> (;
NBC -> );
MUL -> *;
POW -> * *;
PLUS -> +;
MIN -> -;
COMMA -> ,;
DIVIDE -> /;
DIV -> / /;
COLON -> :;
LESS -> <;
EQUAL -> =;
GREAT -> >;
SBO -> [;
SBC -> ];
UNDERSCORE -> _;
CBO -> {;
CBC -> };
PETIK1 -> ';
PETIK2 -> ";
NONES -> none;
ANDS -> and;
ORS -> or;
ISS -> is;
INS -> in;
NOTS -> not;
TRUES -> true;
FALSES -> false;
FORS -> for;
IFS -> if;
ELIFS -> else if;
ELSES -> else;
BREAKS -> break;
CONTINUES -> continue;
WHILES -> while;
DEFS -> function;
RETURNS -> return;
CLASSS -> class;
FROMS -> from;
IMPORTS -> import;
SEMICOLON -> ;;
VAR -> var;